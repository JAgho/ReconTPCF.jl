var documenterSearchIndex = {"docs":
[{"location":"histrecon.html#Reconstruction","page":"Reconstruction","title":"Reconstruction","text":"","category":"section"},{"location":"histrecon.html","page":"Reconstruction","title":"Reconstruction","text":"CurrentModule = ReconTPCF\r\nDocTestSetup = quote\r\n    using ReconTPCF\r\nend","category":"page"},{"location":"histrecon.html","page":"Reconstruction","title":"Reconstruction","text":"The reconstruction algorithm uses simulated annealing to drive a system to minimise a cost function. This cost function is the mismatch in the two-point correlation function between an ideal state and a present one. After initialising the system with a trial (random) binary image, we move towards an image with similar C_2 and S_2. This is done via a series of discrete pixel substitutions. After each substitution, we calculate how C_2 and S_2 have changed by subtracting those pixel's original contributions. We then add the new contribution to C_2 and S_2 from the substitution. By this we reduce the needed number of computations.","category":"page"},{"location":"histrecon.html","page":"Reconstruction","title":"Reconstruction","text":"This is simple for S_2 as we simply compute all contributions from the pixels involved in the swap and find the difference. For C_2 we must first determine which collections of pixels are involved in the interaction, then compute their contributions to C_2 and S_2.","category":"page"},{"location":"histrecon.html#Adjusting-the-reconstruction-algorithm","page":"Reconstruction","title":"Adjusting the reconstruction algorithm","text":"","category":"section"},{"location":"histrecon.html","page":"Reconstruction","title":"Reconstruction","text":"The temperature is currently set automatically, but this could instead be driven by a schedule more complex than geometric decay.","category":"page"},{"location":"histrecon.html","page":"Reconstruction","title":"Reconstruction","text":"Surface optimisation is key to the success of the algorithm as it reduces the set of pixels permitted to mutate. Despite this, it biases the resultant reconstruction towards larger particles, and hinders the closing of bridges. Several convolutional stages could help to reduce this tendency and better settle the system.","category":"page"},{"location":"histrecon.html","page":"Reconstruction","title":"Reconstruction","text":"It may be worth using more aggressive shuffles to begin with and fully recompute C_2 and S_2.","category":"page"},{"location":"histrecon.html","page":"Reconstruction","title":"Reconstruction","text":"histrecon(dims, C2, S2, philen)\r\nget_C2_S2(fname)","category":"page"},{"location":"histrecon.html#ReconTPCF.histrecon-NTuple{4,Any}","page":"Reconstruction","title":"ReconTPCF.histrecon","text":"histrecon_u(dims, C2, S2, philen)\n\nReconstruct a binary image on the basis of input C2 and S2. The size of the reconstructed image is determined by dims, and the number of pixels set to one by philen\n\nThis returns a full suite of statistics about the reconstructed object to check stability.\n\nExample\n\ndims, C2, S2, philen = get_C2_S2(fname)\nguess, S2n, C2n, S2_BN1, C2_BN1, SN1 = histrecon((200, 200)), C2, S2, 12000)\n\n\n\n\n\n","category":"method"},{"location":"histrecon.html#ReconTPCF.get_C2_S2-Tuple{Any}","page":"Reconstruction","title":"ReconTPCF.get_C2_S2","text":"get_C2_S2(fname)\n\nCompute C2 and S2 for an existing binary image fname\n\n\n\n\n\n","category":"method"},{"location":"library.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"library.html","page":"API","title":"API","text":"CurrentModule = ReconTPCF\r\nDocTestSetup = quote\r\n    using ReconTPCF\r\nend","category":"page"},{"location":"library.html","page":"API","title":"API","text":"Modules = [ReconTPCF]","category":"page"},{"location":"library.html#ReconTPCF.C2_initialise-Tuple{Any,Int64}","page":"API","title":"ReconTPCF.C2_initialise","text":"Compute the C2 count in an image. Serves as a starting point for a reconstruction\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.C2_pdist4","page":"API","title":"ReconTPCF.C2_pdist4","text":"C2_pdist4(im, maxrng::Int64, SN::Array{Float64,1}=Array{Float64}(undef, 0))\n\nFast total computation of the C2 count for a\n\n\n\n\n\n","category":"function"},{"location":"library.html#ReconTPCF.S2_finalise-Tuple{Any,Any,Any}","page":"API","title":"ReconTPCF.S2_finalise","text":"Normalise S2 count into S2 proper by dividing by BN and ϕ\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.S2_initialise-Tuple{Any,Any}","page":"API","title":"ReconTPCF.S2_initialise","text":"Find the S2 count for an image\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.blas_stat4-Tuple{Any,Float64,Any}","page":"API","title":"ReconTPCF.blas_stat4","text":"blas_stat4(indx, step::Float64, maxrng)::Array{Int64,1}\n\nComputes a very fast multithreaded probabilistic S2 count. Employs kernel density estimation in place of a true histogram. Gives hilarious results when used for reconstruction.\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.blas_stat5-Tuple{Any,Any}","page":"API","title":"ReconTPCF.blas_stat5","text":"Compute the S2 count (multithreaded, O(N) memory)\n\nFor a list of N CartesianIndex tuples, compute and bin the L2 norm between all pixel pairs in the list.\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.blas_stat_st2-Tuple{Any,Float64,Any}","page":"API","title":"ReconTPCF.blas_stat_st2","text":"blas_stat_st2(indx, step, maxrng)\n\nFor a set of N points, compute the unique distance between all possible pairs of points. Bins distance measurements with a histogram of bin width step and length maxrng Single threaded implementation, greedy with memory. Good for smaller computations\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.check_edge-Tuple{Any,Any,Any}","page":"API","title":"ReconTPCF.check_edge","text":"Prevent fetch_locale from colliding with image edges by providing a reduced window if an edge is collided with\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.cluster_stat-Tuple{Any,Float64,Any}","page":"API","title":"ReconTPCF.cluster_stat","text":"cluster_stat(clusters, step::Float64, maxrng)\n\nFast compution of S2 count for an array of arrays of cartesian indices. Multithreaded in the sense that\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.compute_change!-NTuple{5,Any}","page":"API","title":"ReconTPCF.compute_change!","text":"Sloppy computation to find the contribution to C2 count from the old state and the new, and hence the difference between them.\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.disk_strel-Tuple{Any}","page":"API","title":"ReconTPCF.disk_strel","text":"Compute a binary disk-shaped structure element given radius r on the basis of (areal) interpolation\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.fetch_locale-NTuple{5,Any}","page":"API","title":"ReconTPCF.fetch_locale","text":"Fetch the region around a pixel selection; give a reduced window if near an edge\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.find_equivalent-Tuple{Any,Any,Any}","page":"API","title":"ReconTPCF.find_equivalent","text":"Computes equivalent position of unique entry in a shortlist to an entry in a master list. Uses a much more sensible tupled pick\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.find_unique_regions-Tuple{Any}","page":"API","title":"ReconTPCF.find_unique_regions","text":"Examine which clusters are present in multiple windows simultaneously to determine which clusters are due to change from a pixel swap\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.fragment!-NTuple{5,Any}","page":"API","title":"ReconTPCF.fragment!","text":"Compute the L2 norm between points (xi, yi) and the arrays (arrx, arry) and write to preallocated array dist\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.get_clusters-NTuple{4,Any}","page":"API","title":"ReconTPCF.get_clusters","text":"Fuses clusters to reduce the scale of the problem\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.get_rand_pix-Tuple{Any}","page":"API","title":"ReconTPCF.get_rand_pix","text":"get_rand_pix((pix))::Tuple{Array{CartesianIndex{2},1},Array{CartesianIndex{2},1}}\n\nSelect a random white and black pixel from a tupled pair of lists of cartesian coordinates\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.get_region_names-Tuple{Any}","page":"API","title":"ReconTPCF.get_region_names","text":"Find all unique values present in a small window into the region adjacent to a pixel selection. Used to interrogate a cluster labelled image\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.inner_blas2-Tuple{Array{Float32,1},Array{Float32,1},Array{Float32,1},UInt64}","page":"API","title":"ReconTPCF.inner_blas2","text":"inner_blas2(x, y, dist, len)\n\ncompute the lower triangular self-interaction matrix of a list of N items. gives a flat vector of F32, of length (N(N-1)/2). Interaction here is computing the L2 norm, but could be otherwise.\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.loadim-Tuple{String}","page":"API","title":"ReconTPCF.loadim","text":"Loads and thresholds an image\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.make_rand_im-Tuple{Any,Any}","page":"API","title":"ReconTPCF.make_rand_im","text":"make_rand_im(philen, dims)\n\ncreate a random binary array of size dims with philen white pixels set within it. Also return a coordinate list for white and black pixels\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.monodisp_circ-Tuple{Any,Any,Any}","page":"API","title":"ReconTPCF.monodisp_circ","text":"Generate isotropically distributed circles that may overlap. Keep the implied phase fraction ϕ below 0.3 if possible\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.naninf-Tuple{Any}","page":"API","title":"ReconTPCF.naninf","text":"Eliminates NaN and Inf in an array\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.nonzero-Tuple{Any}","page":"API","title":"ReconTPCF.nonzero","text":"nonzero(image)\n\nevaluate where an image is nonzero\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.pick_rand_coord-Tuple{Tuple{Array{CartesianIndex{2},1},Array{CartesianIndex{2},1}}}","page":"API","title":"ReconTPCF.pick_rand_coord","text":"Selects random elements in a pair of lists\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.pre_proc-Tuple{Any}","page":"API","title":"ReconTPCF.pre_proc","text":"pre_proc(im)\n\nconvolve image with a disk-shaped structure element\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.subtract_cluster-Tuple{Any,Any}","page":"API","title":"ReconTPCF.subtract_cluster","text":"Deduct the contribution of a given set of pixels from a previously calculated S2 count\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.surf_opt-Tuple{Array{Bool,2}}","page":"API","title":"ReconTPCF.surf_opt","text":"Get list of all surface pixels from a 2d binary image using convolution to discriminate Sanitised version to prevent the function returning nothing\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.surf_opt2-Tuple{Array{Bool,2}}","page":"API","title":"ReconTPCF.surf_opt2","text":"Get list of all surface pixels from a 2d binary image using convolution to discriminate\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.surf_rand-Tuple{Any,Any}","page":"API","title":"ReconTPCF.surf_rand","text":"Find the intersection between two tupled lists of cartesian indices We use this to create a segment of a list that maintains ordering\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.swap_pix-NTuple{4,Any}","page":"API","title":"ReconTPCF.swap_pix","text":"Update tuple of 2 cartesian indices by swapping elements from each list at linear index wpick (for 1) and bpick (for 0)\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.update_C2_BN-Tuple{Any,Any,Array{Int64,2},Array{Int64,2},Any,Any,Any}","page":"API","title":"ReconTPCF.update_C2_BN","text":"Computes the C2 count change between a pair of images with one pixel swapped between them\n\n\n\n\n\n","category":"method"},{"location":"library.html#ReconTPCF.update_S2_BN-NTuple{6,Any}","page":"API","title":"ReconTPCF.update_S2_BN","text":"Compute the update to S2 count. Find the contribution from all white pixel's distance from wpick and bpick, and the difference between them\n\n\n\n\n\n","category":"method"},{"location":"index.html#ReconTPCF.jl","page":"ReconTPCF.jl","title":"ReconTPCF.jl","text":"","category":"section"},{"location":"index.html","page":"ReconTPCF.jl","title":"ReconTPCF.jl","text":"ReconTPCF is a toolbox for the (re)construction of binary images based on the method of  Torquato and Yeong. It also collects  a set of efficient functions for computing S_2 and C_2, the two-point  correlation function, and equivalent cluster correlation function. Under specialised  conditions, functions exist to update S2 and C2 as pairs or groups of pixels change  value.","category":"page"},{"location":"index.html#Installation","page":"ReconTPCF.jl","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"ReconTPCF.jl","title":"ReconTPCF.jl","text":"ReconTPCF is a Julia package and hence may be installed simply using the package manager:","category":"page"},{"location":"index.html","page":"ReconTPCF.jl","title":"ReconTPCF.jl","text":"    julia> ]\r\n    pkg> add https://github.com/JAgho/ReconTPCF.jl","category":"page"},{"location":"index.html","page":"ReconTPCF.jl","title":"ReconTPCF.jl","text":"This will add the package and any dependencies it has.","category":"page"},{"location":"index.html#Using-ReconTPCF-For-Reconstruction","page":"ReconTPCF.jl","title":"Using ReconTPCF For Reconstruction","text":"","category":"section"},{"location":"index.html","page":"ReconTPCF.jl","title":"ReconTPCF.jl","text":"Calling using ReconTPCF will give access to its exported functions. This includes get_C2_S2(fname) and histrecon() which are an initialiser and the main reconstruction loop respectively. Histrecon is presently adjusted by modifying its function definition. A typical use of it would look like:","category":"page"},{"location":"index.html","page":"ReconTPCF.jl","title":"ReconTPCF.jl","text":"    dims, C2, S2, philen = get_C2_S2(fname)\r\n    guess, S2n, C2n, S2_BN1, C2_BN1, SN1 = histrecon((200, 200)), C2, S2, 12000)","category":"page"},{"location":"index.html","page":"ReconTPCF.jl","title":"ReconTPCF.jl","text":"Further detail regarding the algorithm is given in its own page in the sidebar","category":"page"},{"location":"index.html#Using-ReconTPCF-for-Computing-The-Two-Point-Correlation-Function","page":"ReconTPCF.jl","title":"Using ReconTPCF for Computing The Two-Point Correlation Function","text":"","category":"section"},{"location":"index.html","page":"ReconTPCF.jl","title":"ReconTPCF.jl","text":"ReconTPCF has fast algorithms for computing S2 for large and small collections in several ways. For long lists of points, a multithreaded implementation is provided; blas_stat5. For shorter lists a single thread function is given; blas_stat_st2. These functions consider all unique pairs in the list and compute the L2 norm for these. These are histogrammed according to the secondary arguments of these functions.","category":"page"}]
}
